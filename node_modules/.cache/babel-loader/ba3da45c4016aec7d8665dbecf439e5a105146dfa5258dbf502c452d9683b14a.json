{"ast":null,"code":"import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, createCommentVNode as _createCommentVNode, createElementVNode as _createElementVNode } from \"vue\";\nconst _hoisted_1 = {\n  class: \"typewriter-container\"\n};\nconst _hoisted_2 = {\n  ref: \"textContainer\",\n  class: \"typewriter-text\"\n};\nconst _hoisted_3 = {\n  key: 0,\n  class: \"heading\"\n};\nconst _hoisted_4 = {\n  key: 0,\n  class: \"cursor\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"div\", _hoisted_2, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.displayedSections, (section, index) => {\n    return _openBlock(), _createElementBlock(\"div\", {\n      key: index,\n      class: \"section\"\n    }, [section.heading ? (_openBlock(), _createElementBlock(\"h3\", _hoisted_3, _toDisplayString(section.heading), 1 /* TEXT */)) : _createCommentVNode(\"v-if\", true), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(section.content, (line, lineIndex) => {\n      return _openBlock(), _createElementBlock(\"div\", {\n        key: lineIndex,\n        class: \"content-line\"\n      }, _toDisplayString(line), 1 /* TEXT */);\n    }), 128 /* KEYED_FRAGMENT */))]);\n  }), 128 /* KEYED_FRAGMENT */))], 512 /* NEED_PATCH */), $data.isTyping ? (_openBlock(), _createElementBlock(\"span\", _hoisted_4)) : _createCommentVNode(\"v-if\", true)]);\n}","map":{"version":3,"names":["class","ref","key","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","_Fragment","_renderList","$data","displayedSections","section","index","heading","_hoisted_3","_toDisplayString","_createCommentVNode","content","line","lineIndex","isTyping","_hoisted_4"],"sources":["F:\\IVIS_PROJECTS\\2025\\JULY\\cbse\\src\\components\\TypewriterText.vue"],"sourcesContent":["<!-- src/components/TypewriterText.vue -->\r\n<template>\r\n  <div class=\"typewriter-container\">\r\n    <div ref=\"textContainer\" class=\"typewriter-text\">\r\n      <div v-for=\"(section, index) in displayedSections\" :key=\"index\" class=\"section\">\r\n        <h3 v-if=\"section.heading\" class=\"heading\">{{ section.heading }}</h3>\r\n        <div v-for=\"(line, lineIndex) in section.content\" :key=\"lineIndex\" class=\"content-line\">\r\n          {{ line }}\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <span class=\"cursor\" v-if=\"isTyping\"></span>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'TypewriterText',\r\n  props: {\r\n    text: {\r\n      type: String,\r\n      required: true\r\n    },\r\n    speed: {\r\n      type: Number,\r\n      default: 1000 // milliseconds per section (heading + content)\r\n    },\r\n    delay: {\r\n      type: Number,\r\n      default: 0 // delay before starting animation in milliseconds\r\n    },\r\n    startOnIntersect: {\r\n      type: Boolean,\r\n      default: true // start typing when component comes into view\r\n    },\r\n    headingPattern: {\r\n      type: RegExp,\r\n      default: () => /^(#{1,6})\\s+(.+)$|^(\\d+\\.)\\s+(.+)$|^([A-Z][^:]*):?\\s*$/ // matches markdown headings, numbered headings, or capitalized headings\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      displayedSections: [],\r\n      currentSectionIndex: 0,\r\n      isTyping: false,\r\n      timeoutId: null,\r\n      observer: null,\r\n      textSections: []\r\n    }\r\n  },\r\n  mounted() {\r\n    // Parse text into sections with headings and content\r\n    this.parseTextIntoSections();\r\n\r\n    if (this.startOnIntersect) {\r\n      // Use Intersection Observer to detect when the element is visible\r\n      this.setupIntersectionObserver();\r\n    } else {\r\n      // Start typing immediately after the specified delay\r\n      setTimeout(() => {\r\n        this.startTyping();\r\n      }, this.delay);\r\n    }\r\n  },\r\n  beforeUnmount() {\r\n    this.cleanup();\r\n  },\r\n  watch: {\r\n    text() {\r\n      // Update sections if text prop changes\r\n      this.parseTextIntoSections();\r\n      this.reset();\r\n    }\r\n  },\r\n  methods: {\r\n    parseTextIntoSections() {\r\n      const lines = this.text.split('\\n').filter(line => line.trim() !== '');\r\n      this.textSections = [];\r\n\r\n      let currentSection = {\r\n        heading: null,\r\n        content: []\r\n      };\r\n\r\n      lines.forEach(line => {\r\n        const trimmedLine = line.trim();\r\n\r\n        // Check if this line is a heading\r\n        if (this.isHeading(trimmedLine)) {\r\n          // If we have content in the current section, save it\r\n          if (currentSection.heading || currentSection.content.length > 0) {\r\n            this.textSections.push({ ...currentSection });\r\n          }\r\n\r\n          // Start a new section with this heading\r\n          currentSection = {\r\n            heading: this.cleanHeading(trimmedLine),\r\n            content: []\r\n          };\r\n        } else {\r\n          // This is content for the current section\r\n          currentSection.content.push(trimmedLine);\r\n        }\r\n      });\r\n\r\n      // Add the last section if it has content\r\n      if (currentSection.heading || currentSection.content.length > 0) {\r\n        this.textSections.push(currentSection);\r\n      }\r\n\r\n      // If no sections were created, create one with all content\r\n      if (this.textSections.length === 0) {\r\n        this.textSections = [{\r\n          heading: null,\r\n          content: lines\r\n        }];\r\n      }\r\n    },\r\n\r\n    isHeading(line) {\r\n      // Check for various heading patterns\r\n      return (\r\n        line.match(/^#{1,6}\\s+.+$/) ||  // Markdown headings (# ## ###)\r\n        line.match(/^\\d+\\.\\s+.+$/) ||   // Numbered headings (1. 2. 3.)\r\n        line.match(/^[A-Z][^:]*:?\\s*$/) || // Capitalized headings (HEADING: or HEADING)\r\n        line.match(/^[A-Z][a-z\\s]+:?\\s*$/) // Title case headings (Title Case:)\r\n      );\r\n    },\r\n\r\n    cleanHeading(heading) {\r\n      // Remove markdown symbols, numbers, and clean up the heading\r\n      return heading\r\n        .replace(/^#{1,6}\\s+/, '')  // Remove markdown #\r\n        .replace(/^\\d+\\.\\s+/, '')  // Remove numbering\r\n        .replace(/:?\\s*$/, '')     // Remove trailing colon and spaces\r\n        .trim();\r\n    },\r\n\r\n    startTyping() {\r\n      if (this.isTyping) return;\r\n\r\n      this.isTyping = true;\r\n      this.currentSectionIndex = 0;\r\n      this.displayedSections = [];\r\n      this.typeNextSection();\r\n    },\r\n\r\n    typeNextSection() {\r\n      if (this.currentSectionIndex < this.textSections.length) {\r\n        this.displayedSections.push({ ...this.textSections[this.currentSectionIndex] });\r\n        this.currentSectionIndex++;\r\n\r\n        // Schedule the next section\r\n        this.timeoutId = setTimeout(() => {\r\n          this.typeNextSection();\r\n        }, this.speed);\r\n      } else {\r\n        // Typing is complete\r\n        this.isTyping = false;\r\n      }\r\n    },\r\n\r\n    reset() {\r\n      this.cleanup();\r\n      this.displayedSections = [];\r\n      this.currentSectionIndex = 0;\r\n      this.isTyping = false;\r\n    },\r\n\r\n    setupIntersectionObserver() {\r\n      const options = {\r\n        root: null, // viewport\r\n        rootMargin: '0px',\r\n        threshold: 0.1 // trigger when at least 10% of the element is visible\r\n      };\r\n\r\n      this.observer = new IntersectionObserver((entries) => {\r\n        entries.forEach(entry => {\r\n          if (entry.isIntersecting && !this.isTyping && this.currentSectionIndex === 0) {\r\n            setTimeout(() => {\r\n              this.startTyping();\r\n            }, this.delay);\r\n          }\r\n        });\r\n      }, options);\r\n\r\n      this.observer.observe(this.$refs.textContainer);\r\n    },\r\n\r\n    cleanup() {\r\n      if (this.timeoutId) {\r\n        clearTimeout(this.timeoutId);\r\n      }\r\n\r\n      if (this.observer) {\r\n        this.observer.disconnect();\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.typewriter-container {\r\n  display: inline-block;\r\n  line-height: 1.6;\r\n  width: 100%;\r\n}\r\n\r\n.typewriter-text {\r\n  white-space: pre-wrap;\r\n  word-break: break-word;\r\n}\r\n\r\n.section {\r\n  margin-bottom: 1.5em;\r\n}\r\n\r\n.section:last-child {\r\n  margin-bottom: 0;\r\n}\r\n\r\n.heading {\r\n  font-weight: bold;\r\n  font-size: 1.2em;\r\n  color: #17b5b5;\r\n  margin-bottom: 0.5em;\r\n  margin-top: 0;\r\n}\r\n\r\n.content-line {\r\n  margin-bottom: 0.3em;\r\n  padding-left: 0.5em;\r\n}\r\n\r\n.content-line:last-child {\r\n  margin-bottom: 0;\r\n}\r\n\r\n.cursor {\r\n  display: inline-block;\r\n  width: 2px;\r\n  height: 1em;\r\n  background-color: #17b5b5;\r\n  margin-left: 2px;\r\n  vertical-align: text-bottom;\r\n  animation: blink 0.7s infinite;\r\n}\r\n\r\n@keyframes blink {\r\n\r\n  0%,\r\n  100% {\r\n    opacity: 1;\r\n  }\r\n\r\n  50% {\r\n    opacity: 0;\r\n  }\r\n}\r\n</style>"],"mappings":";;EAEOA,KAAK,EAAC;AAAsB;;EAC1BC,GAAG,EAAC,eAAe;EAACD,KAAK,EAAC;;;EAHnCE,GAAA;EAKmCF,KAAK,EAAC;;;EALzCE,GAAA;EAWUF,KAAK,EAAC;;;uBATdG,mBAAA,CAUM,OAVNC,UAUM,GATJC,mBAAA,CAOM,OAPNC,UAOM,I,kBANJH,mBAAA,CAKMI,SAAA,QATZC,WAAA,CAIsCC,KAAA,CAAAC,iBAAiB,EAJvD,CAImBC,OAAO,EAAEC,KAAK;yBAA3BT,mBAAA,CAKM;MAL8CD,GAAG,EAAEU,KAAK;MAAEZ,KAAK,EAAC;QAC1DW,OAAO,CAACE,OAAO,I,cAAzBV,mBAAA,CAAqE,MAArEW,UAAqE,EAAAC,gBAAA,CAAvBJ,OAAO,CAACE,OAAO,oBALrEG,mBAAA,iB,kBAMQb,mBAAA,CAEMI,SAAA,QARdC,WAAA,CAMyCG,OAAO,CAACM,OAAO,EANxD,CAMqBC,IAAI,EAAEC,SAAS;2BAA5BhB,mBAAA,CAEM;QAF6CD,GAAG,EAAEiB,SAAS;QAAEnB,KAAK,EAAC;0BACpEkB,IAAI;;0DAIcT,KAAA,CAAAW,QAAQ,I,cAAnCjB,mBAAA,CAA4C,QAA5CkB,UAA4C,KAXhDL,mBAAA,e","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}